'use strict';

// ------------------------------------------------------------------------

var cs = require('./cookie-util')
,   url = require('url');

// ------------------------------------------------------------------------

function TransactionRules(agent) {
  this.agent = agent;
  this.customMatches = undefined;
  this.customExcludes = undefined;
}

exports.TransactionRules = TransactionRules;

TransactionRules.prototype.init = function() {
    var self = this;

    self.customMatches = [];
    self.customExcludes = [];

    self.agent.on('configUpdated', function() {
        var matches = self.agent.configManager.getConfigValue('txConfig.nodejsWeb.customDefinitions')
        ,   excludes = self.agent.configManager.getConfigValue('txConfig.nodejsWeb.discoveryConfig.excludes')
        ,   discovery = self.agent.configManager.getConfigValue('txConfig.nodejsWeb.discoveryConfig.enabled');

        matches = matches || [];
        excludes = excludes || [];

        // keep matches in priority order
        matches = matches.sort(function(r1, r2) { return r1.priority - r2.priority });

        // format custom naming rules
        matches.map(function(customMatch) {
            var http = customMatch.condition.http;
            if (http && Array.isArray(http.properties)) {
                http.properties = self.agent.configManager.convertListToMap(http.properties);
            }
        });

        // map any header names to lower case
        matches.forEach(headerRuleToLowerCase);
        excludes.forEach(headerRuleToLowerCase);

        // update matches / excludes
        self.customMatches = matches || [];
        self.customExcludes = excludes || [];
        self.discoveryEnabled = !!discovery;
    });
};

TransactionRules.prototype.accept = function(req, transaction) {
    if (this.match(req, transaction)) return true;
    if (this.discoveryEnabled) return !this.exclude(req);
    return false;
};

TransactionRules.prototype.match = function(req, transaction) {
    var self = this;

    if (self.customMatches && self.customMatches.length) {
        for (var i = 0; i < self.customMatches.length; i++) {
            if (TransactionRules.matchesRule(req, self.customMatches[i].condition.http)) {
                self.agent.logger.log('transaction matched: ' + self.customMatches[i].btName);
                transaction.customNaming = self.customMatches[i].condition.http.properties;
                transaction.customMatch = self.customMatches[i];
                transaction.isAutoDiscovered = false;
                return true;
            }
        }
    }

    return false;
};

TransactionRules.prototype.exclude = function(req) {
    var self = this;

    for (var i = 0; i < self.customExcludes.length; i++) {
        if (TransactionRules.matchesRule(req, self.customExcludes[i].http)) {
            return true;
        }
    }

    return false;
};

TransactionRules.matchesRule = function(req, rule) {
    var matches = true, uri, host, port, pair;
    
    uri = url.parse(req.url).pathname;
    pair = req && req.headers && req.headers.host && req.headers.host.split(':');
    port = pair && pair[1] || req.connection.localPort;
    host = pair && pair[0] || 'localhost';

    if ('method' in rule) matches = matches && rule.method == req.method;
    if ('uri'    in rule) matches = matches && matchAndLogError(rule.uri,  uri);
    if ('host'   in rule) matches = matches && matchAndLogError(rule.host, host);
    if ('port'   in rule) matches = matches && matchAndLogError(rule.port, port);

    matches = matches && matchGetPostParams(req, rule);
    matches = matches && matchCookies(req, rule);
    matches = matches && matchHeaders(req, rule);

    return matches;
};

// ------------------------------------------------------------------------

function headerRuleToLowerCase(rule) {
    var headers = rule && (rule.headers || (rule.condition && rule.condition.http && rule.condition.http.headers));
    if (headers) headers.forEach(function(headerRule) {
        if (headerRule.key && headerRule.key.matchStrings) {
            headerRule.key.matchStrings = headerRule.key.matchStrings.map(function(header) {
                return header.toLowerCase();
            });
        }
    });
}

function matchGetPostParams(req, rule) {
    var getParams = url.parse(req.url || '/', true).query,
        postParams = req.body || {}, // NOTE: requires Express
        paramRules = rule.params || [],
        paramRule;

    for (var i = 0; i < paramRules.length; i++) {
        paramRule = paramRules[i];
        if (!matchKeyValue(paramRule, getParams) && !matchKeyValue(paramRule, postParams)) {
            return false;
        }
    }

    return true;
}

function matchCookies(req, rule) {
    var cookies = cs.parseCookies(req),
        cookieRules = rule.cookies || [],
        cookieRule;

    for (var i = 0; i < cookieRules.length; i++) {
        cookieRule = cookieRules[i];
        if (!matchKeyValue(cookieRule, cookies)) {
            return false;
        }
    }

    return true;
}

function matchHeaders(req, rule) {
    var headers = req.headers,
        headerRules = rule.headers || [],
        headerRule;

    for (var i = 0; i < headerRules.length; i++) {
        headerRule = headerRules[i];
        if (!matchKeyValue(headerRule, headers)) {
            return false;
        }
    }

    return true;
}

// ------------------------------------------------------------------------
// Condition matching routines

var MatchKeyValueCondition = ['CHECK_FOR_EXISTENCE', 'COMPARE_VALUE'].reduce(
    function(map, item) { map[item] = item; return map; }, {})

var MatchCondition = ['EQUALS', 'STARTS_WITH', 'ENDS_WITH', 'CONTAINS', 'MATCHES_REGEX', 'IS_IN_LIST', 'IS_NOT_EMPTY'].reduce(
    function(map, item) { map[item] = item; return map; }, {});

var MatchResult = ['MATCHED', 'UNMATCHED', 'INVALID_REGEX', 'INVALID_CONDITION', 'EMPTY_CONDITION'].reduce(
    function(map, item, index) { map[item] = index; return map; }, {});

function matchRepeatedKeyValue(rules, keyValuePairs) {
    if (!rules) return true;
    
    for (var i = 0; i < rules.length; i++) {
        if (!matchKeyValue(rules[i], keyValuePairs)) {
            return false;
        }
    }

    return true;
}

function matchKeyValue(match, keyValuePairs) {
    var type  = match.type, 
        key   = match.key, 
        value = match.value;

    if (key && key.matchStrings && key.matchStrings.length == 0) return true;

    // If keyValueMatch key or value are repeated, not a valid key/value mapping.
    if (key && key.matchStrings && key.matchStrings.length > 1) return false;
    if (value && value.matchStrings && value.matchStrings.length > 1) return false;

    // find a keyValuePairs entries whose key name matches...
    for (var item in keyValuePairs) {
        if (matchString(key, item) == MatchResult.MATCHED) {
            // ...which is enough on check exists...
            if (type == 'CHECK_FOR_EXISTENCE') return true;

            // ...otherwise see if its value matches:
            if (matchString(value, keyValuePairs[item]) == MatchResult.MATCHED) {
                return true;
            }
        }
    }

    return false; // invalid type
}

function matchString(condition, input) {
    var match = true, type = condition.type, strings = condition.matchStrings, regex;

    if (!(strings && strings.length)) {
        return ((type != MatchCondition.IS_NOT_EMPTY && type != MatchCondition.IS_IN_LIST)
                    ? MatchResult.INVALID_CONDITION 
                    : MatchResult.EMPTY_CONDITION);
    }

    if (strings.length == 1) {
        switch (type) {
            case MatchCondition.IS_IN_LIST:
            case MatchCondition.EQUALS:
                match = strings[0] == input;
                break
            case MatchCondition.STARTS_WITH:
                match = input.indexOf(strings[0]) == 0;
                break;
            case MatchCondition.CONTAINS:
                match = input.indexOf(strings[0]) >= 0;
                break;
            case MatchCondition.ENDS_WITH:
                match = input.substr(-strings[0].length) == strings[0];
                break;
            case MatchCondition.IS_NOT_EMPTY:
                match = input.length > 0;
                break;
            case MatchCondition.MATCHES_REGEX:
                try {
                    regex = new RegExp(strings[0])
                } catch (e) {
                    return MatchResult.INVALID_REGEX;
                }
                match = regex.test(input);
                break;
            default:
                match = false;
        }
    } else {
        match = false;  
        if (type == MatchCondition.IS_IN_LIST) {
            for (var i = 0; i < strings.length; i++) {
                if (input == strings[i]) {
                    match = true;
                    break;
                }
            }
        }
    }

    return match ^ condition.isNot ? MatchResult.MATCHED : MatchResult.UNMATCHED;
}

function matchAndLogError(condition, input) {
    var err, result;

    result = matchString(condition, input);    
    if (result == MatchResult.EMPTY_CONDITION) return true;
    
    if (result == MatchResult.INVALID_REGEX) err = "MatchResult has invalid regex: " + condition.matchStrings[0];
    else if (result == MatchResult.INVALID_CONDITION) err = "MatchResult is invalid: the condition has zero match strings.";
    if (err) this.agent.logger.error(err);

    return result == MatchResult.MATCHED;
}

// export for unit testing
TransactionRules.Matcher = {
    MatchKeyValueCondition: MatchKeyValueCondition,
    MatchCondition: MatchCondition,
    MatchResult: MatchResult,

    matchRepeatedKeyValue: matchRepeatedKeyValue,
    matchKeyValue: matchKeyValue,
    matchString: matchString,

    match: matchString
};

// ------------------------------------------------------------------------
