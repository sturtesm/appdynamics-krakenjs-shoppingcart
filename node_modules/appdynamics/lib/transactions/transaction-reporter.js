'use strict';


function TransactionReporter(agent) {
  this.agent = agent;
  this.enabled = undefined;
  this.markTransactionAsError = undefined;
}
exports.TransactionReporter = TransactionReporter;


TransactionReporter.prototype.init = function() {
  var self = this;

  self.enabled = false;

  var configManager = self.agent.configManager;
  var registry = self.agent.transactionRegistry;
  var naming = self.agent.transactionNaming;
  var rules = self.agent.transactionRules;


  self.agent.on('configUpdated', function() {
    var txConfig = configManager.getConfigValue('txConfig');
    var enabled = configManager.getConfigValue('txConfig.nodejsWeb.enabled');
    if(txConfig && enabled !== undefined) {
      self.enabled = enabled;
    }
    self.markTransactionAsError = self.agent.configManager.getConfigValue('errorConfig.errorDetection.markTransactionAsError');
  });


  self.agent.on('transactionStarted', function(transaction, req) {
    if(!self.enabled) {
      transaction.ignore = true;
      return;
    }

    if (!rules.accept(req, transaction)) {
      transaction.ignore = true;
      return;
    }

    transaction.name = naming.createHttpTransactionName(req, transaction);
    self.agent.logger.log('transaction name: ' + transaction.name)
    
    if(!transaction.name) {
      transaction.ignore = true;
      self.agent.logger.log("cannot create transaction name");
      return;
    }

    if(registry.isExcludedTransaction(transaction)) {
      transaction.ignore = true;
      return;
    }

    registry.matchTransaction(transaction, req);

    self.agent.proxyTransport.sendBTInfoRequest(transaction);
  });


  self.agent.on('transaction', function(transaction) {
    if(!self.enabled || transaction.ignore) return;

    transaction.hasErrors = self.hasErrors(transaction);

    if(transaction.exitCalls) {
      transaction.exitCalls.forEach(function(exitCall) {
        registry.matchBackendCall(exitCall);
      });
    }

    self.agent.proxyTransport.sendTransactionDetails(transaction);
  });
}


TransactionReporter.prototype.hasErrors = function(transaction) {
  var self = this;

  // this relates to error only, not exceptions
  /*if(self.markTransactionAsError === false) {
    return false;
  }*/

  if(transaction.error) {
    return true;
  }

  var result = false;
  if(transaction.exitCalls) {
    transaction.exitCalls.forEach(function(exitCall) {
      if(exitCall.error) {
        result = true;
      }
    });
  }
  return result;
}
