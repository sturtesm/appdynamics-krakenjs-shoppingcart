'use strict';

var url = require('url');


function HttpProbe(agent) {
  this.agent = agent;

  this.packages = ['http', 'https'];
}
exports.HttpProbe = HttpProbe;



HttpProbe.prototype.attach = function(obj) {
  var self = this;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;

  var proxy = self.agent.proxy;
  var profiler = self.agent.profiler;


  // server probe
  proxy.before(obj.Server.prototype, ['on', 'addListener'], function(obj, args) {
    if(args[0] !== 'request') return;

    if(obj.__httpProbe__) return;
    obj.__httpProbe__ = true;

    proxy.callback(args, -1, function(obj, args) {
      var req = args[0];
      var res = args[1];
      var time = profiler.time(true);

      var transaction = profiler.startTransaction(time, req);

      proxy.after(res, 'end', function(obj, args) {
        var error = res.__caughtException__;
        if(error) res.__caughtException__ = undefined;

        if(!time.done()) return;

        transaction.method = req.method;
        transaction.url = req.url;
        transaction.requestHeaders = req.headers;
        transaction.statusCode = res.statusCode;
        transaction.stackTrace = profiler.formatStackTrace(error);
        transaction.error = error;

        profiler.endTransaction(time, transaction);
      });
    });
  });



  // client probe

  function clientCallback(locals) {
    if(!locals.time.done()) return;

    if(!locals.opts.port) {
      // by default port will be 80 for http, 443 for https
      // but we don't know what protocol is in play, so we
      // need to dig up the actual port used 
      try {
        locals.opts.port = locals.res.req.connection.socket.remotePort;
      } catch (e) {
        self.agent.logger.error('Unable to determine port for outgoing HTTP request.');
        return;
      }
    }

    var sample = profiler.createExitCall();
    sample.method = locals.opts.method;
    sample.command =
      (locals.opts.hostname || locals.opts.host) +
      (locals.opts.port ? ':' + locals.opts.port : '') +
      (locals.opts.path || '/');
    sample.requestHeaders = locals.opts.headers;
    if(locals.res) {
      sample.responseHeaders = locals.res.headers;
      sample.stausCode = locals.res.statusCode;
    }
    sample.stackTrace = locals.stackTrace;
    sample.error = locals.error
    sample.identifyingProperties = {
      HOST: locals.opts.hostname || locals.opts.host,
      PORT: locals.opts.port
    };
    sample.label = locals.opts.protocol + '//' + (locals.opts.hostname || locals.opts.host) + ':' + locals.opts.port;
    sample.exitType = 'EXIT_HTTP';
    sample.category = ((locals.opts.method === 'POST' || locals.opts.method === 'PUT') ? "write" : "read");
    sample.backendName = 'HTTP';

    profiler.addExitCall(locals.time, sample);
  }

  // support 0.11.x and further
  if(obj.globalAgent && obj.globalAgent.request) {
    obj = obj.globalAgent;
  }

  proxy.around(obj, 'request', function(obj, args, locals) {
    if(typeof(args[0]) === 'string') {
      locals.opts = url.parse(args[0]);
    }
    else {
      locals.opts = args[0];
    }

    locals.stackTrace = profiler.stackTrace();
    locals.group = (locals.opts.method || 'GET');
    locals.time = profiler.time();

    proxy.callback(args, -1, function(obj, args) {
      var res = locals.res = args[0];
      proxy.before(res, ['on', 'addListener'], function(obj, args) {
        // workaround for end event
        if(args[0] === 'data' && obj.on !== undefined) {
          obj.on('end', function() {});
        }

        if(args[0] !== 'end') return;

        clientCallback(locals);
      });
    });
  },
  function(obj, args, ret, locals) {
    proxy.before(ret, 'end', function(obj, args, orig) {
      var endCallDone = false;
      function endCallOnce() {
        if(!endCallDone) {
          endCallDone = true;

          // set correlation headers here using locals.transaction
          return orig();
        }
      }

      locals.transaction = profiler.getTransaction(locals.time.threadId);
      if(locals.transaction && !locals.transaction.btInfoResponse) {
        setTimeout(function() {
          // timeout while waiting for btInfoResponse
          return endCallOnce();
        }, 10);

        locals.transaction.once('btInfoResponse', function() {
          // got btInfoResponse
          return endCallOnce();
        });
      }
      else {
        // has btInfoResponse
        return endCallOnce();
      }
    }, false, true);

    proxy.before(ret, ['on', 'addListener'], function(obj, args) {
      if(args[0] == 'response') {
        proxy.callback(args, -1, function(obj, args) {
          clientCallback(locals);
        });
      }
      else if(args[0] == 'error') {
        proxy.callback(args, -1, function(obj, args) {
          locals.error = args[0];
          clientCallback(locals);
        });
      }
    });
  });
};
